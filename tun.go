package main

import (
	"errors"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"os"
	"strconv"

	"golang.org/x/crypto/bcrypt"
	"gopkg.in/mflag.v1"
)

var (
	usePin  bool
	pinLen  int
	port    int
	verbose bool
	useURL  bool
)

var (
	pin   string
	bhash []byte
)

func init() {
	mflag.IntVar(&port, []string{"p", "-port"}, 5051, "a port used by the server")
	mflag.BoolVar(&useURL, []string{"u", "-url"}, false, "take an url as source")
	mflag.BoolVar(&usePin, []string{"pin", "-pin"}, false, "use a PIN code that will protect this tun (random alphanumeric)")
	mflag.StringVar(&pin, []string{"-set-pin"}, "", "set a custom PIN code to override the autogenerated one")
	mflag.IntVar(&pinLen, []string{"-pin-len"}, 4, "specify the length of a randomly generated alphanumeric PIN")
	mflag.BoolVar(&verbose, []string{"v", "-verbose"}, false, "be verbose")
	mflag.Usage = func() {
		errorf("Usage: %s [option] <dir|url>\n", os.Args[0])
		errorln("Spawns an http server that serves files from the specified directory or URL.")
		errorln("\nOPTIONS:")
		mflag.PrintDefaults()
	}
	//
	mflag.Parse()
	if len(mflag.Args()) < 1 {
		mflag.Usage()
		os.Exit(1)
	}
}

func main() {
	port := strconv.Itoa(port)
	if usePin {
		if len(pin) == 0 {
			pin = getAlphanumericPin(pinLen)
		}
		if hash, err := bcrypt.GenerateFromPassword([]byte(pin), bcrypt.DefaultCost); err != nil {
			panic(err)
		} else {
			bhash = hash
		}
	}
	if useURL {
		u := mflag.Arg(0)
		uri, err := url.Parse(u)
		if err != nil {
			fatalln("unable to parse URL:", err)
		}
		if len(uri.Scheme) == 0 {
			uri.Scheme = "http"
		}
		http.Handle("/", http.HandlerFunc(
			authHandler(
				proxyHandler(uri),
			),
		))
	} else {
		dir := mflag.Arg(0)
		if info, err := os.Stat(dir); err != nil {
			fatalln(err)
		} else if !info.IsDir() {
			fatalf("stat %s: not a directory", dir)
		}
		http.Handle("/", http.HandlerFunc(
			authHandler(
				http.FileServer(
					http.Dir(dir),
				),
			),
		))
	}
	if verbose {
		if ip, err := getIP(); err != nil {
			errorln("unable to list entrypoints:", err)
		} else {
			fmt.Printf("entrypoint: http://%s:%s\n", ip.String(), port)
		}
	}
	if usePin {
		fmt.Printf("pin: %s\n", pin)
	}
	if err := http.ListenAndServe(":"+port, nil); err != nil {
		fatalln(err)
	}
}

func getIP() (addr net.IP, err error) {
	var addrs []net.Addr
	if addrs, err = net.InterfaceAddrs(); err != nil {
		return
	}
	for i := range addrs {
		if ipnet, ok := addrs[i].(*net.IPNet); ok {
			if ipnet.IP.IsGlobalUnicast() && ipnet.IP.To4() != nil {
				return ipnet.IP, nil
			}
		}
	}
	return nil, errors.New("no public ip found")
}

func authHandler(h http.Handler) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		prompt := `Basic realm="Enter the PIN"`
		_, pass, ok := r.BasicAuth()
		if !ok {
			w.Header().Set("WWW-Authenticate", prompt)
			w.WriteHeader(http.StatusUnauthorized)
			return
		}
		if err := bcrypt.CompareHashAndPassword(bhash, []byte(pass)); err != nil {
			w.Header().Set("WWW-Authenticate", prompt)
			http.Error(w, "unauthorized: invalid PIN or no PIN provided", http.StatusUnauthorized)
			return
		}
		h.ServeHTTP(w, r)
	}
}

func proxyHandler(u *url.URL) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		resp, err := http.Get(u.String() + r.RequestURI)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.WriteHeader(resp.StatusCode)
		io.Copy(w, resp.Body)
		resp.Body.Close()
	}
}

func isHTTPS(u *url.URL) bool {
	return u.Scheme == "https"
}
